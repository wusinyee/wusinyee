<!DOCTYPE html><html><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;"><meta http-equiv="x-dns-prefetch-control" content="off"><meta name="x-poe-datastore-behavior" content="disabled"><meta name="x-poe-allow-downloads" content="true"><script src="https://puc.poecdn.net/standard.3ef2c256959faf5a756d.js"></script>
    <meta charset="utf-8">
    <title>radial synaptic network</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://puc.poecdn.net/disableWebRTC.9710cebe07429a9e8e06.js"></script><script src="https://puc.poecdn.net/tw.b9024aecac666455e183.js"></script><script src="https://puc.poecdn.net/deps.faccd16000d314dc16d5.js"></script><script src="https://puc.poecdn.net/exports.b0f0f482cdeb5302b0b9.js"></script><script src="https://puc.poecdn.net/renderer.75c73ae6b4235f62945a.js"></script><script>Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _react = require('react'); var _react2 = _interopRequireDefault(_react);
var _framermotion = require('framer-motion');

 function RadialSynapticNetwork() {
  const [hoveredNode, setHoveredNode] = _react.useState.call(void 0, null);
  const [selectedPattern, setSelectedPattern] = _react.useState.call(void 0, 'full');
  const [animateConnections, setAnimateConnections] = _react.useState.call(void 0, true);
  const [nodeCount, setNodeCount] = _react.useState.call(void 0, 36);

  // Configuration constraints
  const MIN_NODES = 12;
  const MAX_NODES = 72;

  // Create nodes in a circle
  const radius = 250;
  const centerX = 300;
  const centerY = 300;

  // Generate rainbow colors
  const generateRainbowColor = (index, total) => {
    const hue = (index / total) * 360;
    return `hsl(${hue}, 85%, 60%)`;
  };

  // Calculate node positions and colors
  const nodes = _react.useMemo.call(void 0, () => {
    return Array.from({ length: nodeCount }, (_, i) => {
      const angle = (i / nodeCount) * 2 * Math.PI - Math.PI / 2;
      return {
        id: i,
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
        angle: angle,
        color: generateRainbowColor(i, nodeCount)
      };
    });
  }, [nodeCount]);

  // Generate connections with different patterns
  const connections = _react.useMemo.call(void 0, () => {
    const conns = [];
    
    switch (selectedPattern) {
      case 'full':
        const connectionOffsets = nodeCount <= 24 ? [3, 7, 11] : 
                                 nodeCount <= 48 ? [5, 11, 17] : 
                                 [7, 13, 19, 29];
        
        nodes.forEach((node, i) => {
          connectionOffsets.forEach(offset => {
            if (offset < nodeCount) {
              const targetIndex = (i + offset) % nodeCount;
              conns.push({
                from: i,
                to: targetIndex,
                id: `${i}-${targetIndex}`
              });
            }
          });
        });
        break;
        
      case 'star':
        nodes.forEach((node, i) => {
          const opposite = (i + Math.floor(nodeCount / 2)) % nodeCount;
          if (i < nodeCount / 2) {
            conns.push({
              from: i,
              to: opposite,
              id: `${i}-${opposite}`
            });
          }
        });
        break;
        
      case 'spiral':
        const spiralOffset = Math.max(3, Math.floor(nodeCount / 3));
        nodes.forEach((node, i) => {
          const next = (i + spiralOffset) % nodeCount;
          conns.push({
            from: i,
            to: next,
            id: `${i}-${next}`
          });
        });
        break;
        
      case 'web':
        const webOffsets = nodeCount <= 24 ? [1, 5] : 
                          nodeCount <= 48 ? [2, 8, 16] : 
                          [3, 12, 24];
        
        nodes.forEach((node, i) => {
          webOffsets.forEach(offset => {
            if (offset < nodeCount / 2) {
              const targetIndex = (i + offset) % nodeCount;
              conns.push({
                from: i,
                to: targetIndex,
                id: `${i}-${targetIndex}`
              });
            }
          });
        });
        break;
    }
    
    return conns;
  }, [selectedPattern, nodes, nodeCount]);

  // Generate curved path with inward curves
  const generateCurvedPath = (fromNode, toNode) => {
    const dx = toNode.x - fromNode.x;
    const dy = toNode.y - fromNode.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    const midX = (fromNode.x + toNode.x) / 2;
    const midY = (fromNode.y + toNode.y) / 2;
    
    // Calculate control point that curves toward center
    const centerPullFactor = 0.3;
    const controlX = midX + (centerX - midX) * centerPullFactor;
    const controlY = midY + (centerY - midY) * centerPullFactor;
    
    return `M ${fromNode.x} ${fromNode.y} Q ${controlX} ${controlY} ${toNode.x} ${toNode.y}`;
  };

  // Handle node count changes
  const handleNodeCountChange = (value) => {
    const newCount = Math.max(MIN_NODES, Math.min(MAX_NODES, parseInt(value) || MIN_NODES));
    setNodeCount(newCount);
  };

  // Inline styles for dark theme
  const containerStyle = {
    width: '100%',
    height: '100vh',
    backgroundColor: '#0a0a0a',
    position: 'relative',
    overflow: 'hidden',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  };

  const controlPanelStyle = {
    position: 'absolute',
    top: '20px',
    left: '20px',
    backgroundColor: 'rgba(20, 20, 20, 0.95)',
    borderRadius: '12px',
    padding: '20px',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.5)',
    backdropFilter: 'blur(10px)',
    border: '1px solid rgba(255, 255, 255, 0.1)',
    zIndex: 20
  };

  const statsPanelStyle = {
    position: 'absolute',
    top: '20px',
    right: '20px',
    backgroundColor: 'rgba(20, 20, 20, 0.95)',
    borderRadius: '12px',
    padding: '20px',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.5)',
    backdropFilter: 'blur(10px)',
    border: '1px solid rgba(255, 255, 255, 0.1)',
    zIndex: 20
  };

  const buttonStyle = (isActive) => ({
    padding: '8px 16px',
    borderRadius: '6px',
    fontSize: '14px',
    fontWeight: '500',
    cursor: 'pointer',
    transition: 'all 0.3s',
    textTransform: 'capitalize',
    width: '100%',
    border: 'none',
    marginBottom: '8px',
    backgroundColor: isActive ? '#4f46e5' : '#374151',
    color: isActive ? '#ffffff' : '#d1d5db',
    background: isActive ? 'linear-gradient(to right, #7c3aed, #3b82f6)' : '#374151'
  });

  const sliderStyle = {
    width: '100%',
    height: '6px',
    borderRadius: '3px',
    outline: 'none',
    WebkitAppearance: 'none',
    appearance: 'none',
    background: `linear-gradient(to right, #3b82f6 0%, #3b82f6 ${((nodeCount - MIN_NODES) / (MAX_NODES - MIN_NODES)) * 100}%, #374151 ${((nodeCount - MIN_NODES) / (MAX_NODES - MIN_NODES)) * 100}%, #374151 100%)`,
    cursor: 'pointer'
  };

  return (
    _react2.default.createElement('div', { style: containerStyle,}
      /* Dark gradient overlay */
      , _react2.default.createElement('div', { 
        style: {
          position: 'absolute',
          inset: 0,
          background: 'radial-gradient(circle at center, rgba(31, 41, 55, 0.5) 0%, rgba(0, 0, 0, 0.9) 100%)',
          pointerEvents: 'none'
        },}
      )

      /* Controls Panel */
      , _react2.default.createElement('div', { style: controlPanelStyle,}
        , _react2.default.createElement('h3', { style: { color: '#ffffff', fontSize: '18px', fontWeight: 'bold', marginBottom: '16px' },}, "Network Configuration"

        )

        /* Node Count Slider */
        , _react2.default.createElement('div', { style: { marginBottom: '20px' },}
          , _react2.default.createElement('label', { style: { color: '#d1d5db', fontSize: '14px', display: 'block', marginBottom: '8px' },}, "Nodes: "
             , _react2.default.createElement('span', { style: { fontWeight: 'bold', color: '#60a5fa' },}, nodeCount)
          )
          , _react2.default.createElement('input', {
            type: "range",
            min: MIN_NODES,
            max: MAX_NODES,
            step: "6",
            value: nodeCount,
            onChange: (e) => handleNodeCountChange(e.target.value),
            style: sliderStyle,}
          )
          , _react2.default.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: '12px', color: '#6b7280', marginTop: '4px' },}
            , _react2.default.createElement('span', null, MIN_NODES)
            , _react2.default.createElement('span', null, MAX_NODES)
          )
        )

        /* Pattern Selection */
        , _react2.default.createElement('h4', { style: { color: '#d1d5db', fontSize: '14px', marginBottom: '12px' },}, "Connection Pattern"

        )
        , _react2.default.createElement('div', { style: { marginBottom: '16px' },}
          , ['full', 'star', 'spiral', 'web'].map(pattern => (
            _react2.default.createElement('button', {
              key: pattern,
              onClick: () => setSelectedPattern(pattern),
              style: buttonStyle(selectedPattern === pattern),}

              , pattern
            )
          ))
        )

        /* Animation Toggle */
        , _react2.default.createElement('button', {
          onClick: () => setAnimateConnections(!animateConnections),
          style: {
            ...buttonStyle(false),
            marginBottom: 0,
            backgroundColor: '#1f2937'
          },}

          , animateConnections ? 'Pause' : 'Play', " Flow"
        )
      )

      /* Main SVG */
      , _react2.default.createElement('svg', { width: "600", height: "600", style: { filter: 'drop-shadow(0 0 40px rgba(0, 0, 0, 0.8))' },}
        , _react2.default.createElement('defs', null
          /* Gradients */
          , connections.map(conn => {
            const fromNode = nodes[conn.from];
            const toNode = nodes[conn.to];
            return (
              _react2.default.createElement('linearGradient', {
                key: `grad-${conn.id}`,
                id: `gradient-${conn.id}`,
                x1: fromNode.x,
                y1: fromNode.y,
                x2: toNode.x,
                y2: toNode.y,
                gradientUnits: "userSpaceOnUse",}

                , _react2.default.createElement('stop', { offset: "0%", stopColor: fromNode.color, stopOpacity: "0.8",} )
                , _react2.default.createElement('stop', { offset: "100%", stopColor: toNode.color, stopOpacity: "0.8",} )
              )
            );
          })

          /* Filters */
          , _react2.default.createElement('filter', { id: "glow",}
            , _react2.default.createElement('feGaussianBlur', { stdDeviation: "3", result: "coloredBlur",})
            , _react2.default.createElement('feMerge', null
              , _react2.default.createElement('feMergeNode', { in: "coloredBlur",})
              , _react2.default.createElement('feMergeNode', { in: "SourceGraphic",})
            )
          )

          , _react2.default.createElement('filter', { id: "nodeGlow",}
            , _react2.default.createElement('feGaussianBlur', { stdDeviation: "5", result: "coloredBlur",})
            , _react2.default.createElement('feMerge', null
              , _react2.default.createElement('feMergeNode', { in: "coloredBlur",})
              , _react2.default.createElement('feMergeNode', { in: "SourceGraphic",})
            )
          )
        )

        /* Connections */
        , _react2.default.createElement('g', { opacity: "0.9",}
          , connections.map((conn, idx) => {
            const fromNode = nodes[conn.from];
            const toNode = nodes[conn.to];
            const path = generateCurvedPath(fromNode, toNode);

            return (
              _react2.default.createElement(_framermotion.motion.path, {
                key: conn.id,
                d: path,
                stroke: `url(#gradient-${conn.id})`,
                strokeWidth: nodeCount > 48 ? "1" : nodeCount > 36 ? "1.5" : "2",
                fill: "none",
                filter: "url(#glow)",
                initial: { pathLength: 0, opacity: 0 },
                animate: { 
                  pathLength: animateConnections ? [0, 1, 1, 0] : 1, 
                  opacity: animateConnections ? [0, 0.7, 0.7, 0] : 0.6
                },
                transition: {
                  pathLength: {
                    duration: 4,
                    repeat: Infinity,
                    delay: (idx / connections.length) * 4,
                    ease: "easeInOut"
                  },
                  opacity: {
                    duration: 4,
                    repeat: Infinity,
                    delay: (idx / connections.length) * 4,
                    ease: "easeInOut"
                  }
                },}
              )
            );
          })
        )

        /* Nodes */
        , _react2.default.createElement('g', null
          , nodes.map((node, idx) => {
            const isHovered = hoveredNode === node.id;
            const nodeSize = nodeCount > 48 ? 4 : nodeCount > 36 ? 5 : 6;
            
            return (
              _react2.default.createElement(_framermotion.motion.g, {
                key: node.id,
                onMouseEnter: () => setHoveredNode(node.id),
                onMouseLeave: () => setHoveredNode(null),
                initial: { scale: 0, opacity: 0 },
                animate: { scale: 1, opacity: 1 },
                transition: { 
                  delay: idx * 0.02,
                  type: "spring",
                  stiffness: 260,
                  damping: 20
                },}

                /* Outer glow */
                , _react2.default.createElement(_framermotion.motion.circle, {
                  cx: node.x,
                  cy: node.y,
                  r: nodeSize * 2,
                  fill: node.color,
                  fillOpacity: "0.3",
                  animate: {
                    r: isHovered ? nodeSize * 3 : nodeSize * 2,
                    fillOpacity: isHovered ? 0.5 : 0.3
                  },
                  transition: { duration: 0.2 },}
                )

                /* Main node */
                , _react2.default.createElement(_framermotion.motion.circle, {
                  cx: node.x,
                  cy: node.y,
                  r: nodeSize,
                  fill: node.color,
                  filter: "url(#nodeGlow)",
                  animate: {
                    r: isHovered ? nodeSize * 1.2 : nodeSize,
                  },
                  transition: { duration: 0.2 },}
                )

                /* Inner highlight */
                , _react2.default.createElement('circle', {
                  cx: node.x - nodeSize * 0.25,
                  cy: node.y - nodeSize * 0.25,
                  r: nodeSize * 0.3,
                  fill: "white",
                  opacity: "0.7",}
                )

                /* Hover ring */
                , isHovered && (
                  _react2.default.createElement(_framermotion.motion.circle, {
                    cx: node.x,
                    cy: node.y,
                    r: nodeSize,
                    fill: "none",
                    stroke: node.color,
                    strokeWidth: "2",
                    initial: { r: nodeSize, opacity: 1 },
                    animate: {
                      r: nodeSize * 4,
                      opacity: 0
                    },
                    transition: {
                      duration: 0.8,
                      repeat: Infinity
                    },}
                  )
                )
              )
            );
          })
        )
      )

      /* Title */
      , _react2.default.createElement('div', { style: {
        position: 'absolute',
        bottom: '40px',
        left: '50%',
        transform: 'translateX(-50%)',
        textAlign: 'center',
        pointerEvents: 'none'
      },}
        , _react2.default.createElement('h2', { style: {
          fontSize: '32px',
          fontWeight: 'bold',
          background: 'linear-gradient(to right, #a78bfa, #60a5fa, #34d399)',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text',
          marginBottom: '8px'
        },}, "Radial Synaptic Network"

        )
        , _react2.default.createElement('p', { style: { color: '#9ca3af', fontSize: '16px' },}, "Interactive Circular Topology Visualization"

        )
      )

      /* Stats Panel */
      , _react2.default.createElement('div', { style: statsPanelStyle,}
        , _react2.default.createElement('div', { style: { fontSize: '14px', color: '#ffffff' },}
          , _react2.default.createElement('div', { style: { marginBottom: '4px' },}, "Synapses: "
             , _react2.default.createElement('span', { style: { fontWeight: 'bold', color: '#60a5fa' },}, nodeCount)
          )
          , _react2.default.createElement('div', { style: { marginBottom: '4px' },}, "Connections: "
             , _react2.default.createElement('span', { style: { fontWeight: 'bold', color: '#a78bfa' },}, connections.length)
          )
          , _react2.default.createElement('div', null, "Topology: "
             , _react2.default.createElement('span', { style: { fontWeight: 'bold', color: '#34d399', textTransform: 'capitalize' },}, selectedPattern)
          )
        )
      )

      /* Custom slider thumb styles */
      , _react2.default.createElement('style', null, `
        input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 16px;
          height: 16px;
          background: #3b82f6;
          cursor: pointer;
          border-radius: 50%;
          box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
        }
        input[type="range"]::-moz-range-thumb {
          width: 16px;
          height: 16px;
          background: #3b82f6;
          cursor: pointer;
          border-radius: 50%;
          border: none;
          box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
        }
      `)
    )
  );
} exports.default = RadialSynapticNetwork;
</script></head>
  <body>
  

<div id="preview-app"></div></body></html>
